import"../chunks/DsnmJJEf.js";import"../chunks/P3upX6GV.js";import{o as D,a as E}from"../chunks/C0EDHXza.js";import{O as H,f as U,Q as h,R as W,T as _,U as X,a as $,V as q,g,W as F,F as C,X as S}from"../chunks/C2j9Br36.js";import{d as J}from"../chunks/DZtCLdQi.js";import{s as P}from"../chunks/BzIxh_Nn.js";import{i as Q}from"../chunks/BtJyAt0V.js";var V=U(`<h2 class="text-4xl text-primary-text pb-12 border-b border-gray-200/10 mb-8">Conway's Game of Life</h2> <div class="pb-12 border-b border-gray-200/10 mb-8"><h3 class="text-2xl text-primary-text mb-4">康威生命遊戲</h3> <p class="text-primary-text font-light mb-4">康威生命遊戲（Conway's Game of Life），通常簡稱為生命遊戲 （Life），是 1970
		年由英國數學家約翰·何頓·康威（John Horton Conway）設計的一種「細胞自動機」（Cellular
		Automaton）。</p> <p class="text-primary-text font-light">它被稱為「零玩家遊戲」（Zero-player
		game），這意味著它的演化完全由其初始狀態決定，不需要任何後續的玩家輸入。</p></div> <div class="pb-12 border-b border-gray-200/10 mb-8"><h3 class="text-xl text-primary-text mb-4">遊戲規則</h3> <p class="text-primary-text font-light mb-4">生命遊戲在一個二維的方格網格上進行，每個方格（細胞）有兩種狀態：<strong class="svelte-fn7bw3">存活</strong> (Alive) 或<strong class="svelte-fn7bw3">死亡</strong> (Dead)。</p> <p class="text-primary-text font-light mb-4">一個細胞在下一個世代的狀態，取決於其周圍<strong class="svelte-fn7bw3">8 個鄰居</strong>（上、下、左、右、以及四個對角線）當前的存活狀態。</p> <ul class="flex flex-col gap-y-4 text-primary-text mb-8"><li><h4 class="font-bold mb-2">1. 人口稀少 (Underpopulation)</h4> <p class="font-light indent-4">如果一個<strong class="svelte-fn7bw3">存活</strong>細胞的鄰居少於<strong class="svelte-fn7bw3">2</strong> 個，它會因為「孤單」而在下一個世代<strong class="svelte-fn7bw3">死亡</strong>。</p></li> <li><h4 class="font-bold mb-2">2. 穩定存活 (Survival)</h4> <p class="font-light indent-4">如果一個<strong class="svelte-fn7bw3">存活</strong>細胞有<strong class="svelte-fn7bw3">2</strong>或<strong class="svelte-fn7bw3">3</strong> 個存活的鄰居，它會<strong class="svelte-fn7bw3">繼續存活</strong>到下一個世代。</p></li> <li><h4 class="font-bold mb-2">3. 人口過剩 (Overpopulation)</h4> <p class="font-light indent-4">如果一個<strong class="svelte-fn7bw3">存活</strong>細胞的鄰居超過 <strong class="svelte-fn7bw3">3</strong> 個，它會因為「擁擠」而在下一個世代<strong class="svelte-fn7bw3">死亡</strong>。</p></li> <li><h4 class="font-bold mb-2">4. 繁殖 (Reproduction)</h4> <p class="font-light indent-4">如果一個<strong class="svelte-fn7bw3">死亡</strong>細胞<strong class="svelte-fn7bw3">剛好</strong>有<strong class="svelte-fn7bw3">3</strong> 個存活的鄰居，它會因為「繁殖」而在下一個世代變為<strong class="svelte-fn7bw3">存活</strong>狀態。</p></li></ul> <p class="text-primary-text font-light">生命遊戲的魅力在於，僅僅透過這四條簡單的規則，就能從一個簡單的初始圖案演化出極其複雜、無法預測的動態系統。</p></div> <div class="space-y-8 border-b border-gray-200/10 pb-12 mb-8"><div class="border-l-4 border-link-text pl-4"><h5 class="text-lg text-primary-text mb-2">湧現行為 (Emergent Behavior)</h5> <p class="text-primary-text text-sm">系統會自發地產生複雜的結構和行為，這是「湧現」的經典範例。</p></div> <div class="border-l-4 border-link-text pl-4"><h5 class="text-lg text-primary-text mb-2">圖靈完備 (Turing Completeness)</h5> <p class="text-primary-text text-sm">生命遊戲在理論上被證明是「圖靈完備」的，這意味著它（在足夠大的網格和時間下）可以模擬任何電腦演算法，甚至可以建造一個在生命遊戲中運作的生命遊戲。</p></div> <div class="border-l-4 border-link-text pl-4"><h5 class="text-lg text-primary-text mb-2">多樣的模式 (Common Patterns)</h5> <p class="text-primary-text text-sm mb-2">玩家和研究者發現了許多有趣的模式，並為其命名，主要分為三類：</p> <ul class="text-primary-text text-sm space-y-1 ml-4"><li><strong class="svelte-fn7bw3">靜物 (Still Lifes):</strong>保持不變的圖案（例如 "Block" 方塊）。</li> <li><strong class="svelte-fn7bw3">振盪器 (Oscillators):</strong>在幾個狀態之間循環的圖案（例如 "Blinker" 閃爍燈）。</li> <li><strong class="svelte-fn7bw3">太空船 (Spaceships):</strong>會在網格上移動的圖案（最有名的是 "Glider" 滑翔翼）。</li></ul></div></div> <div class="pb-12 border-b border-gray-200/10 mb-8"><h4 class="text-lg text-primary-text mb-2">操作說明</h4> <p class="text-primary-text text-sm mb-4">點擊方格來設定初始的存活細胞，然後按下 Start 開始模擬。你可以隨時暫停來調整細胞狀態。</p></div> <div class="flex flex-col gap-4 mt-6 md:flex-row"><div class="flex flex-row gap-2 w-full md:w-32 md:flex-col"><button aria-label="Start">Start</button> <button aria-label="Pause">Pause</button></div> <canvas id="canvas" class="w-full max-w-xl aspect-square"></canvas></div>`,1);function st(M,R){H(R,!1);let a,r,n=F(null),p,o=[],i=[];const l=8,T=()=>{a=document.getElementById("canvas"),a.width=Math.floor(a.offsetWidth/l)*l,a.height=Math.floor(a.offsetHeight/l)*l,r=a.getContext("2d"),r.fillStyle="#646cff29",r.fillRect(0,0,a.width,a.height)},A=()=>{r.strokeStyle="#000000";for(let e=0;e<=a.width;e+=l)r.beginPath(),r.moveTo(e,0),r.lineTo(e,a.height),r.stroke();for(let e=0;e<=a.height;e+=l)r.beginPath(),r.moveTo(0,e),r.lineTo(a.width,e),r.stroke()},x=()=>{r.clearRect(0,0,a.width,a.height),A(),i=L()},v=(e,t)=>{r.clearRect(e*l+1,t*l+1,l-1,l-1);const s=o[t][e]?"#dfdfd6":"#646cff29";r.fillStyle=s,r.fillRect(e*l+1,t*l+1,l-1,l-1)},B=(e,t)=>[[e-1,t-1],[e,t-1],[e+1,t-1],[e-1,t],[e+1,t],[e-1,t+1],[e,t+1],[e+1,t+1]].filter(([s,c])=>i.some(([f,d])=>f===s&&d===c)).length,L=()=>{let e=[];for(let t=0;t<o.length;t+=1)for(let s=0;s<o[t].length;s+=1){const c=B(s,t),f=i.some(([d,z])=>d===s&&z===t)?[2,3]:[3];o[t][s]=f.includes(c),o[t][s]&&e.push([s,t]),v(s,t)}return e},G=e=>{const t=Math.floor(e.offsetX/l),s=Math.floor(e.offsetY/l);t<0||t>=p||s<0||s>=p||(i.some(([c,f])=>c===t&&f===s)?i=i.filter(([c,f])=>!(c===t&&f===s)):i.push([t,s]),o[s][t]=!o[s][t],v(t,s))},I=()=>{g(n)||C(n,setInterval(()=>{x()},300))},u=()=>{g(n)&&(clearInterval(g(n)),C(n,null))};D(()=>{T(),p=a.width/l,o=new Array(p).fill([]).map(()=>new Array(p).fill(!1)),x()}),E(()=>{u()}),Q();var w=V(),y=h(W(w),10),m=_(y),b=_(m);b.__click=I;var k=h(b,2);k.__click=u,S(m);var O=h(m,2);O.__click=G,S(y),X(()=>{P(b,1,`bg-secondary min-w-16 p-2 cursor-pointer rounded-lg ${g(n)?"text-link-active-text":"text-link-text"}`),P(k,1,`bg-secondary min-w-16 p-2 cursor-pointer rounded-lg ${g(n)?"text-link-text":"text-link-active-text"}`)}),$(M,w),q()}J(["click"]);export{st as component};
